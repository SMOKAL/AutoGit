{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "128b451b-3220-4440-9896-75ac32e919b4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Most recent commit SHA: 1e8581326142b45f2d61a1eacea4db8208290d7c\n",
      "Files changed in the most recent commit:\n",
      "{'Rules/Rule6ValidationProof.sql'}\n",
      "Rule6ValidationProof\n",
      "\n",
      "\n",
      "and the content of the file is: \n",
      "    \n",
      "cte1 as\n",
      " (Select v.validationid,b.time from table1\n",
      "  where v.status='Married'),\n",
      "Rule6ValidationProof as \n",
      "  (Select s.id,s.name,c.validationid from soap s join\n",
      "   cte1 c)Changedoinginthecode123\n",
      "\n",
      "Matching filenames:\n",
      "Report/Report3.sql\n",
      "ReportDummy/Report3Dummy.sql\n",
      "Content between patterns has been updated.\n"
     ]
    }
   ],
   "source": [
    "import requests\n",
    "import base64\n",
    "import datetime\n",
    "import os\n",
    "\n",
    "# GitHub API URL for the repository's commits\n",
    "repo_commits_url = 'https://api.github.com/repos/SMOKAL/AutoGit/commits'\n",
    "# The path to the folder in the repository\n",
    "folder_path = 'Rules/'\n",
    "#Get the token from env variable\n",
    "token=os.getenv('TOKENGIT')\n",
    "# Your GitHub personal access token (optional, but may be required for private repositories or higher rate limits)\n",
    "headers = {\n",
    "    'Authorization': f'token {token}',\n",
    "    'Accept': 'application/vnd.github.v3+json'\n",
    "}\n",
    "# Function to get the most recent commit affecting the folder\n",
    "def get_most_recent_commit(repo_url, folder):\n",
    "    # Make a request to get the commits\n",
    "    params = {'path': folder}\n",
    "    response = requests.get(repo_url, headers=headers, params=params)\n",
    "    response.raise_for_status()  # This will raise an exception for HTTP error codes\n",
    "    # Get the list of commits\n",
    "    commits = response.json()\n",
    "    # Check if there are any commits\n",
    "    if not commits:\n",
    "        print(\"No commits found for the specified folder.\")\n",
    "        return None\n",
    "    # Get the most recent commit\n",
    "    recent_commit = commits[0]\n",
    "    return recent_commit\n",
    "# Function to get the list of files changed in a commit\n",
    "def get_commit_files(commit_sha):\n",
    "    commit_url = f\"{repo_commits_url}/{commit_sha}\"\n",
    "    response = requests.get(commit_url, headers=headers)\n",
    "    response.raise_for_status()  # This will raise an exception for HTTP error codes\n",
    "    commit_data = response.json()\n",
    "    return commit_data['files']\n",
    "\n",
    "\n",
    "#Search Operation to get the files in all the folder which have Start and End patter\n",
    "def fetch_files_with_pattern(repo_owner, repo_name, start_pattern, end_pattern):\n",
    "    headers = {'Accept': 'application/vnd.github.v3+json'}\n",
    "    matching_files = []\n",
    "\n",
    "    def search_folder(folder_path):\n",
    "        base_url = f\"https://api.github.com/repos/{repo_owner}/{repo_name}/contents/{folder_path}\"\n",
    "        response = requests.get(base_url, headers=headers)\n",
    "\n",
    "        if response.status_code != 200:\n",
    "            raise Exception(f\"Failed to fetch repository contents for '{folder_path}': {response.status_code}\")\n",
    "\n",
    "        repo_contents = response.json()\n",
    "\n",
    "        for file_info in repo_contents:\n",
    "            if file_info['type'] == 'file':\n",
    "                file_url = file_info['download_url']\n",
    "                file_response = requests.get(file_url)\n",
    "\n",
    "                if file_response.status_code != 200:\n",
    "                    raise Exception(f\"Failed to fetch file contents: {file_response.status_code}\")\n",
    "\n",
    "                file_content = file_response.text\n",
    "                if start_pattern in file_content and end_pattern in file_content:\n",
    "                    matching_files.append(file_info['path'])  # Use 'path' to include the folder path\n",
    "            elif file_info['type'] == 'dir':\n",
    "                search_folder(file_info['path'])  # Recursively search this directory\n",
    "\n",
    "    # Start the search from the root of the repository\n",
    "    search_folder('')\n",
    "\n",
    "    return matching_files\n",
    "    \n",
    "#This will generate the commit message after the content get overwrite between the start and end pattern in the matching files.    \n",
    "def generate_commit_message(BusinessLogic, content_type):\n",
    "    current_time = datetime.datetime.now()\n",
    "    message = f\"Update::{BusinessLogic}::{content_type} on {current_time.strftime('%Y-%m-%d %H:%M:%S')}\"\n",
    "    return message\n",
    "\n",
    "#This will write the content between the start and end pattern in the matching files.\n",
    "def overwrite_content_in_files(repo_owner, repo_name, matching_files, start_pattern, end_pattern, new_content, token):\n",
    "    headers = {'Accept': 'application/vnd.github.v3+json','Authorization': f'token {token}'}\n",
    "    for file_path in matching_files:\n",
    "        # Get the file content and SHA\n",
    "        content_url = f\"https://api.github.com/repos/{repo_owner}/{repo_name}/contents/{file_path}\"\n",
    "        content_response = requests.get(content_url, headers=headers)\n",
    "        \n",
    "        if content_response.status_code != 200:\n",
    "            raise Exception(f\"Failed to fetch file content for '{file_path}': {content_response.status_code}\")\n",
    "                    \n",
    "        content_info = content_response.json()\n",
    "        file_content = base64.b64decode(content_info['content']).decode('utf-8')\n",
    "        sha = content_info['sha']\n",
    "\n",
    "        # Find and replace the content between the start and end patterns\n",
    "        start_index = file_content.find(start_pattern) + len(start_pattern)\n",
    "        end_index = file_content.find(end_pattern)\n",
    "        updated_content = file_content[:start_index] + new_content + file_content[end_index:]\n",
    "\n",
    "        # Encode the updated content to base64\n",
    "        encoded_content = base64.b64encode(updated_content.encode('utf-8')).decode('utf-8')\n",
    "\n",
    "        # Prepare the update payload\n",
    "        BusinessLogic=filename_without_extension\n",
    "        dynamic_message = generate_commit_message(BusinessLogic,\"Sqlcode\")\n",
    "        update_payload = {'message': dynamic_message ,'content': encoded_content,'sha': sha,'branch': 'main',  \n",
    "                          # Specify the branch if not 'main'\n",
    "                         }\n",
    "        \n",
    "        # Send the update request\n",
    "        update_response = requests.put(content_url, headers=headers, json=update_payload)\n",
    "        if update_response.status_code not in (200, 201):\n",
    "            raise Exception(f\"Failed to update file '{file_path}': {update_response.status_code}\")\n",
    "\n",
    "\n",
    "# Fetch the most recent commit for the folder\n",
    "recent_commit = get_most_recent_commit(repo_commits_url, folder_path)\n",
    "\n",
    "# Fetch and print the filenames of the most recent commit\n",
    "if recent_commit:\n",
    "    commit_sha = recent_commit['sha']\n",
    "    print(f\"Most recent commit SHA: {commit_sha}\")\n",
    "    print(\"Files changed in the most recent commit:\")\n",
    "    commit_files = get_commit_files(commit_sha)\n",
    "    for file in commit_files:\n",
    "        file_path = file['filename']\n",
    "        print({file_path})\n",
    "        # Extract the filename with extension\n",
    "        filename_with_extension = os.path.basename(file_path)\n",
    "\n",
    "        # Split the extension and get just the filename\n",
    "        filename_without_extension, _ = os.path.splitext(filename_with_extension)\n",
    "        print(filename_without_extension)\n",
    "        url = f\"https://raw.githubusercontent.com/SMOKAL/AutoGit/{commit_sha}/{file_path}\"\n",
    "        response1 = requests.get(url)\n",
    "        if response1.status_code == 200:\n",
    "            content=response1.text\n",
    "        else:\n",
    "            print(f'There was  different operation other than Update: {response1.status_code} {response1.reason}')\n",
    "            content='None';\n",
    "        print('\\n')\n",
    "        print(f'and the content of the file is: {'\\n'} {content}')\n",
    "\n",
    "#The Information for usage\n",
    "repo_owner = 'SMOKAL'\n",
    "repo_name = 'AutoGit'\n",
    "#start_pattern = f\"/** Rule Start :{filename_without_extension}     **/\"\n",
    "#end_pattern = f\"/** Rule End :{filename_without_extension}     **/\"\n",
    "start_pattern = f\"#RuleStart:{filename_without_extension}#\"\n",
    "end_pattern = f\"#RuleEnd:{filename_without_extension}#\"\n",
    "new_content = content\n",
    "  # Replace with your GitHub personal access token\n",
    "\n",
    "\n",
    "try:\n",
    "    matching_files = fetch_files_with_pattern(repo_owner, repo_name, start_pattern, end_pattern)\n",
    "    print(\"Matching filenames:\")\n",
    "    for filename in matching_files:\n",
    "        print(filename)\n",
    "    overwrite_content_in_files(repo_owner, repo_name, matching_files, start_pattern, end_pattern, new_content, token)\n",
    "    print(\"Content between patterns has been updated.\")\n",
    "except Exception as e:\n",
    "    print(f\"An error occurred: {e}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "15a3bbeb-f412-4108-8f76-b6b3bd71c1d8",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
